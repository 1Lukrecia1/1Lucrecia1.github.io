<!doctype html>
<html lang="ru">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=1" />
  <title>Cycle</title>
  <script src="https://telegram.org/js/telegram-web-app.js"></script>
  <style>
    :root{
      --bg:#0b0c10; --card:#12141b; --text:#e9ecf1; --muted:#a8b0bd;
      --border: rgba(255,255,255,.08);
      --accent:#6dd6ff; --period:#ff5a7a;
      --periodSoft: rgba(255,90,122,.18);
      --predict: rgba(109,214,255,.18);
      --today: rgba(255,255,255,.10);
      --shadow: 0 10px 30px rgba(0,0,0,.35);
      --radius: 18px;
      --select: rgba(255,255,255,.14);
      --selectBorder: rgba(255,255,255,.28);
    }
    body.tg{ --bg: var(--tg-theme-bg-color, var(--bg)); --muted: var(--tg-theme-hint-color, var(--muted)); }
    *{ box-sizing:border-box; }
    body{
      margin:0; background:var(--bg); color:var(--text);
      font-family:-apple-system,BlinkMacSystemFont,"SF Pro Display",system-ui,Segoe UI,Roboto,Arial;
      -webkit-font-smoothing:antialiased;
      padding:14px 14px 24px;
    }
    .wrap{ max-width:560px; margin:0 auto; display:flex; flex-direction:column; gap:12px; }
    .topbar{ display:flex; align-items:center; justify-content:space-between; gap:10px; padding:10px 12px; }
    .brand{ display:flex; flex-direction:column; gap:2px; }
    .brand .title{ font-size:18px; font-weight:720; letter-spacing:.2px; }
    .brand .sub{ font-size:12px; color:var(--muted); }
    .chip{ padding:8px 10px; border:1px solid var(--border); border-radius:999px; background: rgba(255,255,255,.04); font-size:12px; color:var(--muted); white-space:nowrap; }
    .card{ background:var(--card); border:1px solid var(--border); border-radius:var(--radius); box-shadow:var(--shadow); padding:14px; }
    .row{ display:flex; gap:10px; flex-wrap:wrap; }
    .spacer{ flex:1; }
    .btn{
      border:1px solid var(--border);
      background: rgba(255,255,255,.04);
      color:var(--text);
      padding:10px 12px;
      border-radius:14px;
      font-size:14px;
      font-weight:650;
      cursor:pointer;
      transition: transform .05s ease, background .2s ease;
      user-select:none;
    }
    .btn:active{ transform:scale(.98); }
    .btn.primary{
      background: linear-gradient(135deg, rgba(255,90,122,.95), rgba(255,90,122,.75));
      border-color: rgba(255,90,122,.35);
    }
    .btn.ghost{ background:transparent; }
    .btn.icon{ width:40px; height:40px; display:grid; place-items:center; padding:0; border-radius:14px; }
    .headline{ font-size:16px; font-weight:730; margin-bottom:6px; }
    .muted{ color:var(--muted); font-size:13px; line-height:1.35; }
    .danger{ color:#ff8aa0; }

    .calHead{ display:flex; align-items:center; gap:10px; margin-bottom:10px; }
    .monthTitle{ font-size:16px; font-weight:760; letter-spacing:.2px; }
    .dow{ display:grid; grid-template-columns: repeat(7,1fr); gap:8px; margin-bottom:8px; }
    .dow div{ text-align:center; font-size:11px; color:var(--muted); font-weight:650; letter-spacing:.4px; }

    .calViewport{ position:relative; overflow:hidden; border-radius: 16px; }
    .calTrack{ display:flex; width:300%; transform: translateX(-33.3333%); will-change: transform; }
    .calPage{ width:33.3333%; padding:2px; }

    .grid{ display:grid; grid-template-columns: repeat(7,1fr); gap:8px; }

    .day{
      position:relative;
      height:42px;
      border-radius:14px;
      border:1px solid var(--border);
      background: rgba(255,255,255,.03);
      display:flex; align-items:center; justify-content:center;
      font-weight:700; font-size:14px;
      color:var(--text);
      overflow:hidden;
      cursor:pointer;
      user-select:none;
    }
    .day.out{ opacity:.35; background: transparent; }
    .day.today{ outline:2px solid rgba(255,255,255,.15); background:var(--today); }
    .day.period{ background:var(--periodSoft); border-color: rgba(255,90,122,.28); }
    .day.predict{ background:var(--predict); border-color: rgba(109,214,255,.28); }

    /* ✅ выбранный день для тестинга */
    .day.selected{
      outline: 2px solid var(--selectBorder);
      background: var(--select);
    }
    /* если выбранный день ещё и period/predict — сохраняем подсветку статуса, но даём обводку */
    .day.period.selected{ outline-color: rgba(255,90,122,.55); }
    .day.predict.selected{ outline-color: rgba(109,214,255,.55); }

    .badge{ position:absolute; bottom:6px; right:6px; width:8px; height:8px; border-radius:999px; background: rgba(255,255,255,.35); }
    .day.period .badge{ background:var(--period); }
    .day.predict .badge{ background:var(--accent); }

    .legend{ display:flex; gap:10px; flex-wrap:wrap; margin-top:10px; color:var(--muted); font-size:12px; }
    .leg{ display:flex; align-items:center; gap:6px; padding:6px 10px; border:1px solid var(--border); border-radius:999px; background: rgba(255,255,255,.03); }
    .dot{ width:10px; height:10px; border-radius:999px; background:#777; }
    .dot.period{ background:var(--period); }
    .dot.predict{ background:var(--accent); }

    .toast{
      position: fixed;
      left: 50%;
      bottom: 16px;
      transform: translateX(-50%);
      background: rgba(0,0,0,.75);
      color:#fff;
      padding: 10px 12px;
      border-radius: 999px;
      font-size: 13px;
      opacity: 0;
      pointer-events: none;
      transition: opacity .2s ease;
      max-width: min(560px, calc(100vw - 28px));
      text-align:center;
    }
    .toast.show{ opacity:1; }
    .noSelect { user-select:none; }
  </style>
</head>

<body>
  <div class="wrap">
    <div class="topbar">
      <div class="brand">
        <div class="title">Трекер цикла</div>
        <div class="sub">Тапни по дню → выбери дату для отметки</div>
      </div>
      <div class="chip" id="chipInfo">MVP</div>
    </div>

    <div class="card">
      <div class="headline" id="summaryTitle">Добавь данные</div>
      <div class="muted" id="summaryText">Нажми «Началось» в первый день — после 2 циклов появится прогноз.</div>
      <div class="muted" id="selectedInfo" style="margin-top:8px;"></div>
    </div>

    <div class="card">
      <div class="calHead">
        <button class="btn icon" id="prevBtn" aria-label="Prev month">‹</button>
        <div class="spacer">
          <div class="monthTitle" id="monthTitle">—</div>
        </div>
        <button class="btn icon" id="nextBtn" aria-label="Next month">›</button>
      </div>

      <div class="dow">
        <div>ПН</div><div>ВТ</div><div>СР</div><div>ЧТ</div><div>ПТ</div><div>СБ</div><div>ВС</div>
      </div>

      <div class="calViewport" id="gridViewport">
        <div class="calTrack" id="calTrack">
          <div class="calPage"><div class="grid" id="gridPrev"></div></div>
          <div class="calPage"><div class="grid" id="gridNow"></div></div>
          <div class="calPage"><div class="grid" id="gridNext"></div></div>
        </div>
      </div>

      <div class="legend">
        <div class="leg"><span class="dot period"></span> Факт</div>
        <div class="leg"><span class="dot predict"></span> Прогноз</div>
      </div>
    </div>

    <div class="card">
      <div class="headline">Быстрые действия</div>
      <div class="row">
        <button class="btn primary" id="startBtn">Началось</button>
        <button class="btn" id="endBtn">Закончилось</button>
        <button class="btn ghost" id="exportBtn">Экспорт</button>
        <label class="btn ghost" style="display:inline-flex; align-items:center; gap:8px; cursor:pointer;">
          Импорт
          <input id="importFile" type="file" accept="application/json" style="display:none" />
        </label>
        <button class="btn ghost danger" id="resetBtn">Сброс</button>
        <button class="btn ghost" id="clearSelBtn">Снять выбор</button>
      </div>
      <div class="muted" style="margin-top:10px">
        Если дата выбрана, отметки ставятся на неё. Если не выбрана — на сегодня.
      </div>
    </div>

    <div class="card">
      <div class="headline">История (последние 10)</div>
      <div class="muted" id="history">Пока пусто.</div>
    </div>
  </div>

  <div class="toast" id="toast"></div>

<script>
  // Telegram
  try {
    if (window.Telegram?.WebApp) {
      document.body.classList.add("tg");
      Telegram.WebApp.ready();
      Telegram.WebApp.expand();
    }
  } catch (_) {}

  const KEY = "cycle_app_v3";
  const DEFAULT = { cycles: [], periodLenHint: 5 };

  // Helpers
  const calDay = (d=new Date()) => new Date(d.getFullYear(), d.getMonth(), d.getDate());
  const monthStart = (d) => new Date(d.getFullYear(), d.getMonth(), 1);
  const startOfDayISO = (d) => { const x=new Date(d); x.setHours(0,0,0,0); return x.toISOString(); };
  const parseISO = (iso) => { const d=new Date(iso); d.setHours(0,0,0,0); return d; };
  const sameDay = (a,b) => a.getFullYear()===b.getFullYear() && a.getMonth()===b.getMonth() && a.getDate()===b.getDate();
  const addDays = (d,n) => { const x=new Date(d); x.setDate(x.getDate()+n); return x; };
  const daysBetween = (a,b) => Math.round((parseISO(b).getTime() - parseISO(a).getTime())/(1000*60*60*24));
  const fmtLong = (d) => d.toLocaleDateString("ru-RU",{day:"numeric",month:"long",year:"numeric"});
  const fmtShort = (d) => d.toLocaleDateString("ru-RU",{day:"2-digit",month:"2-digit",year:"numeric"});
  const clamp = (v,min,max) => Math.max(min, Math.min(max,v));
  const isValidISO = (s) => { try { return !!s && !isNaN(new Date(s).getTime()); } catch { return false; } };

  function medianInt(nums){
    const a=[...nums].sort((x,y)=>x-y);
    if(!a.length) return null;
    const n=a.length;
    return n%2 ? a[Math.floor(n/2)] : Math.round((a[n/2-1]+a[n/2])/2);
  }
  function load(){
    const raw=localStorage.getItem(KEY);
    if(!raw) return structuredClone(DEFAULT);
    try { const p=JSON.parse(raw); return { ...structuredClone(DEFAULT), ...p }; }
    catch { return structuredClone(DEFAULT); }
  }
  function save(data){ localStorage.setItem(KEY, JSON.stringify(data)); }
  function toast(msg){
    const el=document.getElementById("toast");
    el.textContent=msg; el.classList.add("show");
    clearTimeout(toast._t);
    toast._t=setTimeout(()=>el.classList.remove("show"), 1500);
  }

  // Cycle math
  function cycleStarts(data){
    return data.cycles.map(c=>parseISO(c.startISO)).sort((a,b)=>a-b);
  }
  function predictNextStart(data){
    const starts=cycleStarts(data);
    if(starts.length<2) return { next:null, medianLen:null };
    const lens=[];
    for(let i=1;i<starts.length;i++){
      const len=daysBetween(starts[i-1], starts[i]);
      if(len>=15 && len<=60) lens.push(len);
    }
    const med=medianInt(lens);
    if(!med) return { next:null, medianLen:null };
    return { next:addDays(starts[starts.length-1], med), medianLen:med };
  }
  function buildDaySets(data){
    const fact=new Set();
    const predict=new Set();

    for(const c of data.cycles){
      const s=parseISO(c.startISO);
      const e=c.endISO ? parseISO(c.endISO) : null;
      const end=e ?? s;
      const span=clamp(daysBetween(s,end), 0, 20);
      for(let i=0;i<=span;i++) fact.add(startOfDayISO(addDays(s,i)));
    }

    const { next }=predictNextStart(data);
    if(next){
      const plen=clamp(Number(data.periodLenHint||5), 1, 10);
      for(let i=0;i<plen;i++) predict.add(startOfDayISO(addDays(next,i)));
    }
    return { fact, predict };
  }

  function monthGridDates(viewMonth){
    const first=new Date(viewMonth.getFullYear(), viewMonth.getMonth(), 1);
    const shift=(first.getDay()+6)%7;
    const start=addDays(first, -shift);
    const dates=[];
    for(let i=0;i<42;i++) dates.push(addDays(start,i));
    return dates;
  }
  function monthName(d){
    return d.toLocaleDateString("ru-RU", { month:"long", year:"numeric" }).replace(/^./, c=>c.toUpperCase());
  }

  // ✅ UI state includes selected date for testing
  const state = {
    view: monthStart(new Date()),
    animating:false,
    selectedISO: null   // если выбрано, сюда пишем ISO start-of-day
  };

  function renderSelectedInfo(){
    const el = document.getElementById("selectedInfo");
    if (state.selectedISO) {
      el.textContent = `Выбранная дата: ${fmtLong(parseISO(state.selectedISO))}`;
    } else {
      el.textContent = "Выбранная дата: нет (будет использоваться сегодня)";
    }
  }

  function renderSummary(){
    const data=load();
    const { next, medianLen }=predictNextStart(data);
    const title=document.getElementById("summaryTitle");
    const text=document.getElementById("summaryText");
    if(next && medianLen){
      title.textContent=`Следующий цикл примерно: ${fmtLong(next)}`;
      text.textContent=`Медиана длины цикла: ${medianLen} дней. Прогноз — голубым.`;
      document.getElementById("chipInfo").textContent=`Медиана ${medianLen}д`;
    } else {
      title.textContent="Добавь данные";
      text.textContent="Чтобы появился прогноз, отметь минимум 2 начала цикла кнопкой «Началось».";
      document.getElementById("chipInfo").textContent="MVP";
    }
    renderSelectedInfo();
  }

  function renderHistory(){
    const data=load();
    const h=document.getElementById("history");
    if(!data.cycles.length){ h.textContent="Пока пусто."; return; }
    const last=data.cycles.slice().sort((a,b)=>parseISO(b.startISO)-parseISO(a.startISO)).slice(0,10);
    h.innerHTML=last.map(c=>{
      const s=fmtShort(parseISO(c.startISO));
      const e=c.endISO ? fmtShort(parseISO(c.endISO)) : "…";
      return `• ${s} — ${e}`;
    }).join("<br/>");
  }

  function fillGrid(gridEl, viewMonth){
    const data=load();
    const { fact, predict }=buildDaySets(data);
    const dates=monthGridDates(viewMonth);
    const month=viewMonth.getMonth();
    const today=calDay(new Date());

    gridEl.innerHTML="";
    for(const d of dates){
      const iso=startOfDayISO(d);
      const el=document.createElement("div");
      el.className="day";

      if(d.getMonth()!==month) el.classList.add("out");
      if(sameDay(d,today)) el.classList.add("today");
      if(fact.has(iso)) el.classList.add("period");
      if(predict.has(iso)) el.classList.add("predict");
      if(state.selectedISO === iso) el.classList.add("selected");

      el.textContent=String(d.getDate());

      const badge=document.createElement("div");
      badge.className="badge";
      el.appendChild(badge);

      el.addEventListener("click", ()=>{
        // toggle selection
        if (state.selectedISO === iso) {
          state.selectedISO = null;
          toast("Выбор снят");
        } else {
          state.selectedISO = iso;
          toast(`Выбрано: ${fmtLong(d)}`);
        }
        renderSelectedInfo();
        // перерисуем только три сетки, чтобы подсветка selected обновилась
        renderMonthTriple();
      });

      gridEl.appendChild(el);
    }
  }

  function renderMonthTriple(){
    document.getElementById("monthTitle").textContent = monthName(state.view);
    const prev = new Date(state.view.getFullYear(), state.view.getMonth()-1, 1);
    const next = new Date(state.view.getFullYear(), state.view.getMonth()+1, 1);
    fillGrid(document.getElementById("gridPrev"), prev);
    fillGrid(document.getElementById("gridNow"), state.view);
    fillGrid(document.getElementById("gridNext"), next);
  }

  function rerenderAll(){
    renderSummary();
    renderMonthTriple();
    renderHistory();
  }

  // ✅ Use selected date if exists, else today
  function effectiveISODate(){
    const todayISO = startOfDayISO(new Date());
    if (state.selectedISO && isValidISO(state.selectedISO)) return state.selectedISO;
    return todayISO;
  }

  // Actions (use effective date)
  function startCycle(){
    const data=load();
    const iso = effectiveISODate();

    if (data.cycles.some(c=>c.startISO===iso)){
      toast("Этот день уже отмечен как старт.");
      return;
    }
    data.cycles.push({ startISO: iso, endISO: null });
    // сортируем по дате старта чтобы прогноз работал ровно
    data.cycles.sort((a,b)=>parseISO(a.startISO)-parseISO(b.startISO));
    save(data);
    rerenderAll();
    toast(`Старт: ${fmtLong(parseISO(iso))}`);
  }

  function endCycle(){
    const data=load();
    const iso = effectiveISODate();

    // закрываем последний незакрытый цикл (по дате старта)
    const openIndex = (() => {
      let idx = -1;
      for (let i = data.cycles.length - 1; i >= 0; i--) {
        if (!data.cycles[i].endISO) { idx = i; break; }
      }
      return idx;
    })();

    if (openIndex === -1){
      toast("Нет активного цикла.");
      return;
    }

    // защита: конец не раньше старта
    const start = parseISO(data.cycles[openIndex].startISO);
    const end = parseISO(iso);
    if (end < start){
      toast("Конец не может быть раньше начала.");
      return;
    }

    data.cycles[openIndex].endISO = iso;
    save(data);
    rerenderAll();
    toast(`Конец: ${fmtLong(end)}`);
  }

  function exportData(){
    const data=load();
    const blob=new Blob([JSON.stringify(data,null,2)], { type:"application/json" });
    const a=document.createElement("a");
    a.href=URL.createObjectURL(blob);
    a.download="cycle-backup.json";
    a.click();
    URL.revokeObjectURL(a.href);
    toast("Экспорт готов.");
  }

  function importData(file){
    const reader=new FileReader();
    reader.onload=()=>{
      try{
        const parsed=JSON.parse(reader.result);
        if(!parsed || !Array.isArray(parsed.cycles)) throw new Error("bad");
        localStorage.setItem(KEY, JSON.stringify({ ...structuredClone(DEFAULT), ...parsed }));
        state.selectedISO = null;
        rerenderAll();
        toast("Импортировано.");
      } catch { toast("Не удалось импортировать."); }
    };
    reader.readAsText(file);
  }

  function resetAll(){
    localStorage.removeItem(KEY);
    state.selectedISO = null;
    rerenderAll();
    toast("Сброшено.");
  }

  function clearSelection(){
    state.selectedISO = null;
    renderSelectedInfo();
    renderMonthTriple();
    toast("Выбор снят");
  }

  // ✅ Animated month switch
  const track = document.getElementById("calTrack");
  function setTrackX(px, withTransition){
    track.style.transition = withTransition ? "transform 220ms cubic-bezier(.2,.8,.2,1)" : "none";
    track.style.transform = `translateX(calc(-33.3333% + ${px}px))`;
  }
  function snapToCenter(){
    setTrackX(0, true);
    track.addEventListener("transitionend", function handler(){
      track.removeEventListener("transitionend", handler);
      track.style.transition = "none";
      track.style.transform = "translateX(-33.3333%)";
    });
  }

  function commitMonth(delta){
    if(state.animating) return;
    state.animating = true;

    const viewport = document.getElementById("gridViewport");
    const w = viewport.clientWidth;
    const targetPx = delta > 0 ? -w : w;

    setTrackX(targetPx, true);

    track.addEventListener("transitionend", function handler(){
      track.removeEventListener("transitionend", handler);
      state.view = new Date(state.view.getFullYear(), state.view.getMonth()+delta, 1);
      renderMonthTriple();
      track.style.transition="none";
      track.style.transform="translateX(-33.3333%)";
      state.animating = false;
    });
  }

  // Buttons
  document.getElementById("prevBtn").addEventListener("click", ()=> commitMonth(-1));
  document.getElementById("nextBtn").addEventListener("click", ()=> commitMonth(+1));

  // Other UI
  document.getElementById("startBtn").addEventListener("click", startCycle);
  document.getElementById("endBtn").addEventListener("click", endCycle);
  document.getElementById("exportBtn").addEventListener("click", exportData);
  document.getElementById("resetBtn").addEventListener("click", resetAll);
  document.getElementById("clearSelBtn").addEventListener("click", clearSelection);
  document.getElementById("importFile").addEventListener("change", (e)=>{
    const f=e.target.files?.[0];
    if(f) importData(f);
    e.target.value="";
  });

  // Swipe with drag
  function attachSwipe(el){
    let startX=0, startY=0, startT=0;
    let dragging=false, locked=false;

    const DIST_THRESHOLD = 0.22;
    const VELOCITY_PX_MS = 0.55;

    function onStart(e){
      if(state.animating) return;
      if(!e.touches || e.touches.length!==1) return;
      const t=e.touches[0];
      startX=t.clientX; startY=t.clientY;
      startT=performance.now();
      dragging=true; locked=false;
      document.body.classList.add("noSelect");
      track.style.transition="none";
    }

    function rubber(dx, width){
      const k=0.35, max=width*0.9;
      const cl=Math.max(-max, Math.min(max, dx));
      return cl * (1 - k*(Math.abs(cl)/max));
    }

    function onMove(e){
      if(!dragging || state.animating) return;
      const t=e.touches[0];
      const dx=t.clientX - startX;
      const dy=t.clientY - startY;

      if(!locked){
        if(Math.abs(dx) < 8 && Math.abs(dy) < 8) return;
        if(Math.abs(dy) > Math.abs(dx) * 1.15){
          dragging=false;
          document.body.classList.remove("noSelect");
          track.style.transform="translateX(-33.3333%)";
          return;
        }
        locked=true;
      }

      e.preventDefault();
      const w=document.getElementById("gridViewport").clientWidth;
      setTrackX(rubber(dx, w), false);
    }

    function onEnd(e){
      if(!dragging || state.animating) return;
      dragging=false;
      document.body.classList.remove("noSelect");

      const endT=performance.now();
      const dt=endT - startT;
      const touch=(e.changedTouches && e.changedTouches[0]) ? e.changedTouches[0] : null;
      if(!touch){ snapToCenter(); return; }

      const dx=touch.clientX - startX;
      const dy=touch.clientY - startY;

      if(Math.abs(dy) > Math.abs(dx) * 1.15){ snapToCenter(); return; }

      const w=document.getElementById("gridViewport").clientWidth;
      const v=Math.abs(dx)/Math.max(dt,1);
      const passed=(Math.abs(dx) > w*DIST_THRESHOLD) || (v > VELOCITY_PX_MS);

      if(!passed){ snapToCenter(); return; }

      commitMonth(dx < 0 ? +1 : -1);
    }

    el.addEventListener("touchstart", onStart, { passive:true });
    el.addEventListener("touchmove", onMove, { passive:false });
    el.addEventListener("touchend", onEnd, { passive:true });
    el.addEventListener("touchcancel", ()=>{ dragging=false; document.body.classList.remove("noSelect"); snapToCenter(); }, { passive:true });
  }

  attachSwipe(document.getElementById("gridViewport"));

  // Initial render
  rerenderAll();
</script>
</body>
</html>
